#include "c.ceu"
#include "sdl/sdl.ceu"

#define WIN_W 640
#define WIN_H 480

#define PI 3.14159265

#define DROPS_PERSEC_MIN  10
#define DROPS_PERSEC_MAX 100

data Vector2D with
	var int x,y;
end;

data Axis with
    var float pos;
    var int   len;
    var float vel;
    var float acc;
    var float drag;
end

data IPhysics with
	var Axis x;
	var Axis y;
end

var& _SDL_Renderer_ptr ren;
watching SDL_go("Storm", WIN_W, WIN_H, SDL_Color(0x21,0x2c,0x34,0x00))
            => (ren)
do
code/await Physics (var SDL_Rect rct, var SDL_Color clr)
                    => (var& IPhysics physics)
                        => void
do
    var IPhysics phys_ = val IPhysics(
                                Axis(rct.x, rct.w, 0, 0, 1),
                                Axis(rct.y, rct.h, 0, 0, 1),
                             );
    physics = &phys_;

	par do
        var int dt_ = _;
	    every dt_ in SDL_DT do
            var float dt = (dt_ as float)/1000;
	    	phys_.x.vel = (phys_.x.vel + phys_.x.acc*dt) * phys_.x.drag;
	    	phys_.y.vel = (phys_.y.vel + phys_.y.acc*dt) * phys_.y.drag;
	        phys_.x.pos = phys_.x.pos + phys_.x.vel*dt;
	        phys_.y.pos = phys_.y.pos + phys_.y.vel*dt;
	    end
	with
	    every SDL_REDRAW do
	        _SDL_SetRenderDrawColor(outer.ren, clr.r, clr.g, clr.b, clr.a);
            var SDL_Rect r = val SDL_Rect(phys_.x.pos as int, phys_.y.pos as int,
                                          phys_.x.len as int, phys_.y.len as int);
	        _SDL_RenderFillRect(outer.ren, (&&r as _SDL_Rect&&));
	    end
	end
end

code/await Drop (var& IPhysics cloud) => void
do
    var SDL_Rect rct = val SDL_Rect((_rand()%cloud.x.len + cloud.x.pos) as int,
                                    (cloud.y.pos + cloud.y.len) as int,
                                    2,
                                    5);
    var& IPhysics drop;
    watching Physics(rct, SDL_Color(0x98, 0xC1, 0xE4, 0))
                => (drop)
    do
        drop.x.vel  = cloud.x.vel;
	    drop.x.drag = 0.98;
	    drop.y.drag = 0.98;
	    drop.y.acc  = 500;	

        await FOREVER;
    end
end

code/await Cloud (var int dps) => void
do
    pool[] Drop drops;

    var int maxy = 2 * 1000 / DROPS_PERSEC_MIN;

    var int freq_ini = 1000 / dps;
	var int freq_cur = freq_ini;
	var int ty = maxy - freq_cur*2;
	if ty < 1 then
        ty = 1;
    end

	var int w = 100 + _rand()%100;
    var SDL_Rect rct = val SDL_Rect(-w, ty, 100+_rand()%100, 20+_rand()%50);

    var int v = 200 - (200*ty / maxy);
	var SDL_Color clr = val SDL_Color(v, (v*0.95) as int, v, 0);

    var int vx = 10 + _rand()%50;

    var& IPhysics cloud;
    watching Physics(rct, clr) => (cloud)
    do
        cloud.x.vel = vx;
        par do
            var int dt;
            every dt in SDL_DT do
                if cloud.x.pos > WIN_W then
                    cloud.x.pos = -cloud.x.len;
                end
            end
        with
            every (freq_cur)ms do
                spawn Drop(&cloud) in drops;
            end
        end
    end
end

code/await Storm (void) => void
do
    pool[] Cloud clouds;

	var int dps_prv = 0;

	loop i in [0 -> 3[ do
        var int dps_cur = (_rand() % (DROPS_PERSEC_MAX-dps_prv)) + DROPS_PERSEC_MIN;
		if dps_cur < 0 then
            dps_cur = 1;
        end
		dps_prv = dps_prv + dps_cur;

		spawn Cloud(dps_cur) in clouds;
	end

    await FOREVER;
end

code/await Wheel (var& IPhysics car, var Vector2D offset) => void
do
	var int radius = 15;
	var float esp = (2 * PI / 12);
	var float pos = 0;
	
	par do
        var int dt = _;
	    every dt in SDL_DT do	    	
	    	var int s = do
                if car.x.vel >= 0 then
                    escape  1;
                else
                    escape -1;
                end
            end;

	    	var float mod = _sqrt(_pow(car.x.vel,2) + _pow(car.y.vel,2));
			pos = pos + (s * mod * dt / 1000 / radius);
        end
    with
        every SDL_REDRAW do
            _SDL_SetRenderDrawColor(outer.ren, 0xFF, 0x9D, 0x46, 0x00);
			loop i in [0 -> 12[ do
                var SDL_Rect r =
                    val SDL_Rect(
                        (car.x.pos + offset.x + (radius * _cos(i*esp + pos))) as int,
                        (car.y.pos + offset.y + (radius * _sin(i*esp + pos))) as int,
                        5, 5
                    );
				_SDL_RenderFillRect(outer.ren, (&&r as _SDL_Rect&&));
			end
        end
	end	
end

code/await Car (void) => void
do
    var& IPhysics car;
    watching Physics(SDL_Rect(320,430, 60,30), SDL_Color(0x3B,0xBC,0x48,0))
                => (car)
    do
        spawn Wheel(&car, Vector2D(        0, car.y.len));
        spawn Wheel(&car, Vector2D(car.x.len, car.y.len));

        car.x.drag = 0.95;
        car.y.drag = 0.95;

        par do
            loop do
                var _SDL_KeyboardEvent&& key;
                key = await SDL_KEYDOWN until key:keysym.sym==_SDLK_LEFT;
                car.x.acc = -400;
                key = await SDL_KEYUP   until key:keysym.sym==_SDLK_LEFT;
                car.x.acc = 0;
            end
        with
            loop do
                var _SDL_KeyboardEvent&& key;
                key = await SDL_KEYDOWN until key:keysym.sym==_SDLK_RIGHT;
                car.x.acc = 400;
                key = await SDL_KEYUP   until key:keysym.sym==_SDLK_RIGHT;
                car.x.acc = 0;
            end
        end
    end
end

    spawn Car();
    spawn Storm();

	await FOREVER;
end

escape 0;

#if 0
#include "sdl.ceu"

#define MAX_GOTAS_PORSEGUNDO 100
#define	GOTAS_DECAY_TIME_MS 2000

// Região de explosão
class Explosao with
	var _SDL_Rect r = _SDL_Rect( 0 , 0 , 30 , 30 );
	var int magnitude = 200;	
	var int raio = 30;
	var Vetor2D pos;

	function (Vetor2D obj_centro)=>Vetor2D getVel;	// Retorna a intensidade da explosao baseado na distancia para o centro dela
do
	// Recalcula o retangulo centrado
	r = _SDL_Rect( phys_.x.pos-raio , phys_.y.pos-raio , raio*2 , raio*2 );
	
	// Retorna a intensidade da explosao baseado na distancia para o centro dela
	function (Vetor2D obj_centro)=>Vetor2D getVel do
		var Vetor2D exp_centro = Vetor2D( (r.x+r.x+r.w)/2 , (r.y+r.y+r.h)/2 );
		var float dist = _sqrt( _pow( (obj_centro.x - exp_centro.x) , 2 ) + _pow( (obj_centro.y - exp_centro.y) , 2) );
		var float perc_dist = dist/raio;

		// Fora do raio
		if( perc_dist > 1 ) then
			var Vetor2D vel = Vetor2D(0,0);
			return vel;
		// Valor minimo
		else/if perc_dist < 0.1 then
			perc_dist = 0.1;
		end
		// Ajusta perc_dist para a formula cossenoidal ( atenuacao nao linear )
		perc_dist = 1.0 - (_cos(perc_dist * PI));	
		// Valores finais
		var Vetor2D vel = Vetor2D( _cos(perc_dist)*magnitude , _sin(perc_dist)*magnitude*-1 );
		// Ajuste de direção
		if obj_centro.x < exp_centro.x then phys_.x.vel = -phys_.x.vel; end
		if obj_centro.y < exp_centro.y then phys_.y.vel = -phys_.y.vel; end

		return vel;
	end
	
	await 100ms;
end


// Gerenciador de colisões globais
class Colisor with
	pool Gota[]& gotas;
	pool Explosao[]& explosoes;
	var PhysOrganism& po;

do
	every dt in SDL_DT do			
		// Colisao gota a gota	
		loop go1 in gotas do
			var PhysOrganism& goPo = &(go1:getPhysOrg());
			// Calcula colisao com o player			
			if _SDL_HasIntersection( &&(po.r) , &&(goPo.r) ) then
				if goPo.r.y < po.r.y then
					// Colisao acima do player
					goPo.phys_.y.pos = po.phys_.y.pos - (goPo.phys_.y.len*1000);		
					goPo.phys_.y.vel = -( goPo.phys_.y.vel / 3 );			
					goPo.phys_.x.vel = po.phys_.x.vel / 2;
					go1:colisoes = go1:colisoes + 1;
				else
					// Colisao nas laterais do player
					goPo.phys_.x.vel = po.phys_.x.vel * 2;
					goPo.phys_.y.vel = -(_abs(po.phys_.x.vel));
				end
			end

			// Calcula colisao com a explosao
			loop ex in explosoes do
				if _SDL_HasIntersection( &&(goPo.r) , &&(ex:r) ) then					
					var Vetor2D vel = Vetor2D( goPo.r.x , goPo.r.y );
					vel = ex:getVel( vel );
					goPo.phys_.x.vel = goPo.phys_.x.vel + (phys_.x.vel*dt);
					goPo.phys_.y.vel = goPo.phys_.y.vel + (phys_.y.vel*dt);
				end
			end

			// Calcula colisao com outras gotas e faz as gotas escorrerem para o lado durante uma colisão
			loop go2 in gotas do
				if go1 > go2 and _SDL_HasIntersection( &&(go1:getPhysOrg().r) , &&(go2:getPhysOrg().r) ) then
					if go1:colisoes > 0 then	
						go1:getPhysOrg().phys_.x.vel = +50;
					end
					if go2:colisoes > 0 then	
						go2:getPhysOrg().phys_.x.vel = -50;
					end
				end
			end
		end //Loop Go1	

		// Colisao das explosoes com o carro
		loop ex in explosoes do
			if _SDL_HasIntersection( &&(po.r) , &&(ex:r) ) then					
				var Vetor2D vel = Vetor2D( po.r.x , po.r.y );
				vel = ex:getVel( vel );
				po.phys_.x.vel = po.phys_.x.vel + (phys_.x.vel*dt/20);
			end
		end		
	end
end

// Relampago
class Relampago with
	var _SDL_Renderer& ren;	
	pool Relampago[]& relampagos;
	pool Explosao[]& explosoes;	

	var Vetor2D pos_inicial;
	var int direcao = 270; // Direcao em graus
	var int caos = 30; // Maximo de aleatoriedade na direcao ( graus )
	var int magnitude = 50; // Distancia percorrida na direcao

	var int fork = 0; // Checa se é um galho
do	
	//Define posicao final do relampago
	var Vetor2D pos_final = Vetor2D( 0 , 0 );
	var float direcaoRad = PI * ( direcao - caos + (_rand()%(caos*2)) ) / 180.0;
	pos_final.x = pos_inicial.x + ( _cos(direcaoRad) * magnitude );
	pos_final.y = pos_inicial.y - ( _sin(direcaoRad) * magnitude );

	//Loop existencial
	par/or do	
		every SDL_REDRAW do
		    _SDL_SetRenderDrawColor(&&this.ren, 0xEA , 0xD7 , 0xFF , 0 );
		    _SDL_RenderDrawLine( &&this.ren ,  pos_inicial.x , pos_inicial.y , pos_final.x , pos_final.y );
		end
	with
		if( pos_final.y >= WIN_H/1000 ) then
			if fork == 0 then
				spawn Explosao in explosoes with
					this.magnitude = 20;	
					this.raio = 80;
					this.pos = Vetor2D( (pos_inicial.x + pos_final.x)/2 , (WIN_H/1000) + (this.raio * 0.20) );					
				end;
			end	
		// Cria outro relampago -> continuação do tronco
		else/if( magnitude > 5 ) then
			await 20ms;
			spawn Relampago in relampagos with
				this.ren = &ren;	
				this.relampagos = &relampagos;
				this.explosoes = &explosoes;
				this.pos_inicial = Vetor2D(  pos_final.x ,  pos_final.y );
				if fork == 0 then this.magnitude = magnitude;
				else this.magnitude = magnitude * 0.9; end
				this.direcao = direcao;
				this.fork = fork;
			end;
			// Cria possivel bifurcação ( outro relampago, so que com magnitude menor )
			if( _rand()%WIN_H > (pos_inicial.y*1000) ) then
				spawn Relampago in relampagos with
					this.ren = &ren;	
					this.relampagos = &relampagos;
					this.explosoes = &explosoes;
					this.pos_inicial = Vetor2D(  pos_inicial.x ,  pos_inicial.y );
					this.magnitude = magnitude * 0.5;
					this.direcao = _rand()%180 + 180;
					this.fork = 1;
				end;
			end
		end		
		await FOREVER;
	with
		// Morre depois de um tempo
		await 150ms;
	end
end


// Criador de gotas de chuva e verificador de colisao
class Temporal with
	var _SDL_Renderer& ren;	

	pool Gota[]& gotas;
	pool Explosao[]& explosoes;
		
	var int nuvem_qtd = 3;
do	
	pool Cloud[] nuvens;
	pool Relampago[] relampago_pool;

	var int gotas_pseg_atual = 0;
		
	// Inicia Temporal
	loop i in nuvem_qtd do
		var int gps = ( _rand()%(MAX_GOTAS_PORSEGUNDO-gotas_pseg_atual) )+MIN_GOTAS_PORSEGUNDO;
		if gps < 0 then gps = 1; end
		gotas_pseg_atual = gotas_pseg_atual + gps;
		spawn Cloud in nuvens with
			var int w = 100 + _rand()%100;
			var int h = 20 + _rand()%50;
			var int y = 5 + _rand()%150;
			this.ren = &ren;
			this.r   = _SDL_Rect(0,y,w,h);
			this.vx  = 10 + _rand()%50;	
			this.gotas = &gotas;
			this.gotasPorSegundo = gps;
		end;
	end
	
	par do
		// Varia tempo
		loop do
			await ( (_rand()%10) + 1 )s;
			loop n in nuvens do
				if (_rand()%nuvem_qtd) > 0 then
					gotas_pseg_atual = gotas_pseg_atual - n:gotasPorSegundo;
					if gotas_pseg_atual > MAX_GOTAS_PORSEGUNDO then
						gotas_pseg_atual = MAX_GOTAS_PORSEGUNDO;
					else/if gotas_pseg_atual < MIN_GOTAS_PORSEGUNDO then
						gotas_pseg_atual = MIN_GOTAS_PORSEGUNDO;
					end;
					var int gps = ( _rand()%(MAX_GOTAS_PORSEGUNDO-gotas_pseg_atual) )+MIN_GOTAS_PORSEGUNDO;
					if gps < 0 then gps = 1; end
					gotas_pseg_atual = gotas_pseg_atual + gps;
					n:gotasPorSegundo = gps;
				end
			end	
			_printf("\nGotas por Segundo atual: %d/%d\n",gotas_pseg_atual,MAX_GOTAS_PORSEGUNDO);
		end
	with
		loop do
			await SDL_DT;
			// Colisão - Detecta se nuvens colidiram para criar relampagos
			var Vetor2D?[] relampagos;
			var Cloud&&?[] nuv1;
			var Cloud&&?[] nuv2;
			loop nu1 in nuvens do
				loop nu2 in nuvens do
					if nu1 > nu2 and _SDL_HasIntersection( &&(nu1:r) , &&(nu2:r) ) then
						var Vetor2D p = Vetor2D( (nu1:r.x + nu2:r.x + nu2:r.w )/2 , (nu1:r.y + nu1:r.h + nu2:r.y + nu2:r.h )/2 );							
						relampagos = []..relampagos..[p]; // Adiciona a relampago ao vetor
						nuv1 = []..nuv1..[nu1];
						nuv2 = []..nuv2..[nu2];	
						break;					
					end
				end
			end
			// Cria relampago
			loop i in $relampagos do
				if relampagos[i]? then
					spawn Relampago in relampago_pool with
						this.ren = &ren;	
						this.pos_inicial = relampagos[i]!;
						this.relampagos = &relampago_pool;
						this.explosoes = &explosoes;
					end;
				end
			end	
			// Pisca nuvens
			loop i in $nuv1 do
				if nuv1[i]? then
					emit nuv1[i]!:pisca;
				end
			end
			loop i in $nuv2 do
				if nuv2[i]? then
					emit nuv2[i]!:pisca;
				end
			end
			// Aguarda delay para o proximo relampago
			await (_rand()%3)s;
		end
	with
		// Debug
		loop do
            var _SDL_KeyboardEvent&& key;
            key = await SDL_KEYDOWN until key:keysym.sym==_SDLK_DOWN;
			spawn Relampago in relampago_pool with
				this.ren = &ren;	
				this.pos_inicial = Vetor2D ( 300 , 0 );
				this.relampagos = &relampago_pool;
				this.explosoes = &explosoes;
			end;			
		end
	end
end

// INICIO DO LOOP DE JOGO

_srand(_time(null));

par/or do
with
	pool Gota[] gotas;
	pool Explosao[] explosoes;


	// Tratador de colisoes
	var Colisor colisor with
		this.po = &(p.getPhysOrg());
		this.gotas = &gotas;
		this.explosoes = &explosoes;
	end;

	// Inicia controlador de chuva
	var Temporal nuvens with
		this.ren = &renderer!;
		this.gotas = &gotas;
		this.explosoes = &explosoes;
	end;

    // Inicializa Anexavel
	var Gira _ with
	    this.ren = &renderer!;
		this.po = &(p.getPhysOrg());
		this.desloc = Vetor2D( 0 , this.po.phys_.y.len);
	end;
	var Gira _ with
	    this.ren = &renderer!;
		this.po = &(p.getPhysOrg());
		this.desloc = Vetor2D( this.po.phys_.x.len , this.po.phys_.y.len);
	end;

    await FOREVER;
end

escape 0;

// e63b95a6905d278fb2ea187f8cad63ede552b4d6
#endif
