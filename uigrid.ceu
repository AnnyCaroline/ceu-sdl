/*{-{*/

// TODO:
// * remaining space from division

input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONDOWN;

class UIGrid with
    interface UI;
    event int           go_ui;
    event int           ok_uiclicked;

    var   int           clr_bg? = 0;        // whole UI background
    var   _SDL_Color    clr_bg;
    var   int           clr_fr? = 0;        // whole UI frame
    var   _SDL_Color    clr_fr;
    var   int           clr_cell_bg? = 0;   // each cell background
    var   _SDL_Color    clr_cell_bg;
    var   int           clr_cell_fr? = 0;   // each cell frame
    var   _SDL_Color    clr_cell_fr;
    var   int           clr_ui_bg? = 0;     // each UI background
    var   _SDL_Color    clr_ui_bg;          // (if existent)
    var   int           clr_ui_fr? = 0;     // each UI frame
    var   _SDL_Color    clr_ui_fr;          // (if existent)

    //var   int           one_x=0, one_y=0;
    var   int           spc_x=0, spc_y=0;
    var   int           pad_x=0, pad_y=0;

    var   int           lay_lins, lay_cols;
    var   u32*          lay      = null;
    var   int           lay_own? = 0;

    var   UI**          uis      = null;
    var   u32           uis_n    = 0;
    var   int           uis_own? = 0;

    //var   UI*           ui_ptr;
    //var   int           ui_own? = 0;        // TODO: change to fun arg

    var _SDL_Rect*      cell_rects = null;
    var _SDL_Rect*      ui_rects   = null;
do
    _assert(this.lay != null);
        finalize with
            if this.lay_own? then
                _free(this.lay);
            end;
        end

    _assert(this.uis != null);
        finalize with
            if this.uis_own? then
                _free(this.uis);
            end;
        end

    loop i, uis_n do
        if uis[i] != null then
            emit uis[i]:go;
        end
    end

    finalize
        cell_rects = _malloc(uis_n * sizeof<_SDL_Rect>);
    with
        _free(cell_rects);
    end

    finalize
        ui_rects = _malloc(uis_n * sizeof<_SDL_Rect>);
    with
        _free(ui_rects);
    end

    var int redimed? = 0;

    par do
        // GO_MOUSEBUTTONDOWN
        await go_redim;
        loop do
            var _SDL_MouseButtonEvent* but = await SDL_MOUSEBUTTONDOWN;
            loop i, uis_n do
                if _SDL_Rect_vs_Mouse(&ui_rects[i], but) then
                    emit ok_uiclicked = i+1;    // 0 are blank spaces
                end
            end
        end
/*
    with
        loop do
            // TODO: problema com ui_ptr mudar
            var int i = await go_ui;
            if ui_ptr != null then
                if ui_own? then     // TODO: change to fun arg
                    free uis[i];
                end
                uis[i] = ui_ptr;
            end
            if redimed? and uis[i]!=null then
                emit uis[i]:go_redim = &ui_rects[i];
            end
        end
*/
    with
        // GO_REDIM
        loop do
            var _SDL_Rect* r = await go_redim;
            redimed? = 1;
            if r != null then
                rect = *r;
            end

            var int one_x = (rect.w-spc_x)/lay_cols - spc_x - 2*pad_x;
            var int one_y = (rect.h-spc_y)/lay_lins - spc_y - 2*pad_y;

            var int x0 = rect.x;
            var int y0 = rect.y;

            var int cur = 0;
            var int x, y;

            loop l, lay_lins do
                x = x0 + spc_x;     // starts from spc_x
                if l == 0 then
                    y = y0 + spc_y; // starts from spc_y
                else
                    y = y + pad_y + one_y + pad_y + spc_y;
                end

                loop c, lay_cols do
                    if c != 0 then
                        x = x + pad_x + one_x + pad_x + spc_x;
                    end

                    var int i1  = l*lay_cols + c;
                    var u8  lay1 = lay[i1];

                    if lay1 > cur then      // always increasing items
                        cur = lay1;
                        _assert(cur <= uis_n);

                        var _SDL_Rect* cell_rect = &cell_rects[cur-1];
                            cell_rect:x = x;
                            cell_rect:y = y;
                            cell_rect:w = one_x + 2*pad_x;
                            cell_rect:h = one_y + 2*pad_y;

                        var _SDL_Rect* ui_rect = &ui_rects[cur-1];
                            ui_rect:x = x+pad_x;
                            ui_rect:y = y+pad_y;
                            ui_rect:w = one_x;
                            ui_rect:h = one_y;

                        // colspan
                        loop j, lay_cols-c-1 do
                            var u8 lay2 = lay[i1 + j+1];
                            if lay1 == lay2 then
                                cell_rect:w = cell_rect:w + spc_x +
                                                one_x + 2*pad_x;
                                ui_rect:w   = ui_rect:w   + spc_x +
                                                one_x + 2*pad_x;
                            else
                                break;
                            end
                        end

                        // linspan
                        loop j, lay_lins-l-1 do
                            var u8 lay2 = lay[i1 + (j+1)*lay_cols];
                            if lay1 == lay2 then
                                cell_rect:h = cell_rect:h + spc_y +
                                                one_y + 2*pad_y;
                                ui_rect:h   = ui_rect:h   + spc_y +
                                                one_y + 2*pad_y;
                            else
                                break;
                            end
                        end
                        if uis[cur-1] then
                            emit uis[cur-1]:go_redim=ui_rect;
                        end
                    end
                end
            end
        end
    with
        await go_redim; // requires 1st redim
        loop do
            var _SDL_Point* pt = await go_move;
            rect.x = rect.x + pt:x;
            rect.y = rect.y + pt:y;
            loop i, uis_n do
                cell_rects[i].x = cell_rects[i].x + pt:x;
                cell_rects[i].y = cell_rects[i].y + pt:y;
                ui_rects[i].x   = ui_rects[i].x + pt:x;
                ui_rects[i].y   = ui_rects[i].y + pt:y;
                if uis[i] then
                    emit uis[i]:go_move=pt;
                end
            end
        end
    with
        await go_redim; // requires 1st redim
        loop do
            var _SDL_Renderer* ren = await go_redraw;
            if clr_bg? then
                _SDL_SetRenderDrawColor(ren, clr_bg.r,clr_bg.g,clr_bg.b,0);
                _SDL_RenderFillRect(ren, &rect);
            end
/*
clr_cell_fr? = 1;
clr_cell_fr.r = 0xFF;
clr_cell_fr.g = 0x00;
clr_cell_fr.b = 0x00;
clr_ui_fr? = 1;
clr_ui_fr.r = 0xFF;
clr_ui_fr.g = 0xFF;
clr_ui_fr.b = 0x00;
*/
            loop i, uis_n do
                if clr_cell_bg? then
                    _SDL_SetRenderDrawColor(ren,
                        clr_cell_bg.r,clr_cell_bg.g,clr_cell_bg.b,0);
                    _SDL_RenderFillRect(ren, &cell_rects[i]);
                end
                if clr_ui_bg? then
                    _SDL_SetRenderDrawColor(ren,
                        clr_ui_bg.r,clr_ui_bg.g,clr_ui_bg.b,0);
                    _SDL_RenderFillRect(ren, &ui_rects[i]);
                end
                if uis[i] then
                    emit uis[i]:go_redraw=ren;
                end
                if clr_cell_fr? then
                    _SDL_SetRenderDrawColor(ren,
                        clr_cell_fr.r,clr_cell_fr.g,clr_cell_fr.b,0);
                    _SDL_RenderDrawRect(ren, &cell_rects[i]);
                end
                if clr_ui_fr? then
                    _SDL_SetRenderDrawColor(ren,
                        clr_ui_fr.r,clr_ui_fr.g,clr_ui_fr.b,0);
                    _SDL_RenderDrawRect(ren, &ui_rects[i]);
                end
            end

            if clr_fr? then
                _SDL_SetRenderDrawColor(ren, clr_fr.r,clr_fr.g,clr_fr.b,0);
                _SDL_RenderDrawRect(ren, &rect);
            end
        end
    end
end

/*}-}*/ dnl
